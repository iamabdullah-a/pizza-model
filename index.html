<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>Enterprise Product Visualization - WebAR</title>
    <script src="https://cdn.jsdelivr.net/npm/aframe@1.4.2/dist/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.3/dist/mindar-image-aframe.prod.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
</head>
<body>
    <a-scene mindar-image="imageTargetSrc: https://cdn.jsdelivr.net/gh/hiukim/mind-ar-js@1.2.3/examples/image-tracking/assets/card-example/card.mind; maxTrack: 1;" color-space="sRGB" renderer="colorManagement: true; toneMapping: ACESFilmic; toneMappingExposure: 0.8;" embedded>
        
        <!-- Anchor entity for stable world-space positioning -->
        <a-entity id="anchor" mindar-image-target="targetIndex: 0">
            <!-- Smoothing container with interpolation -->
            <a-entity id="smoothing-container" smoothing="factor: 0.15; rotationFactor: 0.1">
                <!-- Main product container -->
                <a-entity id="product-container" product-interaction="scaleMin: 0.5; scaleMax: 2.0; rotationSpeed: 0.5">
                    
                    <!-- Lighting setup -->
                    <a-entity light="type: directional; color: #FFFFFF; intensity: 0.8; castShadow: true" 
                              position="2 4 3" shadow="mapSize: 1024"></a-entity>
                    <a-entity light="type: ambient; color: #FFFFFF; intensity: 0.4"></a-entity>
                    <a-entity light="type: hemisphere; color: #87CEEB; groundColor: #8B7355; intensity: 0.6"></a-entity>
                    
                    <!-- Product model with PBR materials -->
                    <a-entity position="0 0.1 0" scale="0.01 0.01 0.01">
                        <a-box position="0 20 0" width="40" height="40" depth="40" 
                               material="metalness: 0.8; roughness: 0.2; envMapIntensity: 1.5; color: #CCCCCC"
                               shadow="cast: true; receive: true">
                        </a-box>
                        
                        <!-- Product details -->
                        <a-cylinder position="0 60 0" radius="15" height="20" 
                                    material="metalness: 0.9; roughness: 0.1; color: #FFD700"
                                    shadow="cast: true; receive: true">
                        </a-cylinder>
                        
                        <a-text value="Enterprise Pro" position="0 100 0" align="center" width="100"
                                color="#FFFFFF" font="https://cdn.aframe.io/fonts/Roboto-msdf.json"
                                negate="false"></a-text>
                    </a-entity>
                    
                    <!-- Shadow catcher -->
                    <a-plane position="0 -0.01 0" rotation="-90 0 0" width="1" height="1"
                             material="opacity: 0.3; transparent: true; shader: shadow"
                             shadow="receive: true"></a-plane>
                </a-entity>
            </a-entity>
        </a-entity>
        
        <!-- UI Elements -->
        <a-entity id="ui">
            <a-text id="scanning-text" value="Scan target marker..." position="0 -1 0" align="center" 
                    visible="true" color="#FFFFFF" scale="2 2 2"></a-text>
        </a-entity>

        <!-- Camera -->
        <a-camera position="0 0 0" wasd-controls-enabled="false"></a-camera>
    </a-scene>

    <script>
        // Smoothing component for position and rotation
        AFRAME.registerComponent('smoothing', {
            schema: {
                factor: {type: 'number', default: 0.1},
                rotationFactor: {type: 'number', default: 0.05}
            },
            
            init: function() {
                this.smoothedPosition = new THREE.Vector3();
                this.smoothedQuaternion = new THREE.Quaternion();
                this.targetPosition = new THREE.Vector3();
                this.targetQuaternion = new THREE.Quaternion();
                
                // Get initial position
                const worldPos = new THREE.Vector3();
                const worldQuat = new THREE.Quaternion();
                this.el.object3D.getWorldPosition(worldPos);
                this.el.object3D.getWorldQuaternion(worldQuat);
                
                this.smoothedPosition.copy(worldPos);
                this.smoothedQuaternion.copy(worldQuat);
            },
            
            tick: function() {
                const data = this.data;
                
                // Get current world position and rotation
                this.el.object3D.getWorldPosition(this.targetPosition);
                this.el.object3D.getWorldQuaternion(this.targetQuaternion);
                
                // Apply smoothing
                this.smoothedPosition.lerp(this.targetPosition, data.factor);
                this.smoothedQuaternion.slerp(this.targetQuaternion, data.rotationFactor);
                
                // Set smoothed values
                this.el.object3D.position.copy(this.smoothedPosition);
                this.el.object3D.quaternion.copy(this.smoothedQuaternion);
            }
        });

        // Product interaction component (rotate/scale)
        AFRAME.registerComponent('product-interaction', {
            schema: {
                scaleMin: {type: 'number', default: 0.5},
                scaleMax: {type: 'number', default: 2.0},
                rotationSpeed: {type: 'number', default: 0.5}
            },
            
            init: function() {
                this.scale = 1.0;
                this.rotationY = 0;
                this.isInteracting = false;
                this.startX = 0;
                this.startScale = 1.0;
                
                this.el.sceneEl.addEventListener('targetFound', this.onTargetFound.bind(this));
                this.el.sceneEl.addEventListener('targetLost', this.onTargetLost.bind(this));
                
                // Touch events
                this.el.sceneEl.canvas.addEventListener('touchstart', this.onTouchStart.bind(this));
                this.el.sceneEl.canvas.addEventListener('touchmove', this.onTouchMove.bind(this));
                this.el.sceneEl.canvas.addEventListener('touchend', this.onTouchEnd.bind(this));
            },
            
            onTargetFound: function() {
                document.querySelector('#scanning-text').setAttribute('visible', false);
            },
            
            onTargetLost: function() {
                document.querySelector('#scanning-text').setAttribute('visible', true);
            },
            
            onTouchStart: function(event) {
                if (event.touches.length === 1) {
                    this.isInteracting = true;
                    this.startX = event.touches[0].clientX;
                } else if (event.touches.length === 2) {
                    this.isInteracting = true;
                    const dx = event.touches[0].clientX - event.touches[1].clientX;
                    const dy = event.touches[0].clientY - event.touches[1].clientY;
                    this.startDistance = Math.sqrt(dx * dx + dy * dy);
                    this.startScale = this.scale;
                }
            },
            
            onTouchMove: function(event) {
                if (!this.isInteracting) return;
                event.preventDefault();
                
                if (event.touches.length === 1) {
                    // Rotation
                    const currentX = event.touches[0].clientX;
                    const deltaX = currentX - this.startX;
                    this.rotationY += deltaX * this.data.rotationSpeed * 0.01;
                    this.startX = currentX;
                    
                    this.el.object3D.rotation.y = this.rotationY;
                } else if (event.touches.length === 2) {
                    // Scaling
                    const dx = event.touches[0].clientX - event.touches[1].clientX;
                    const dy = event.touches[0].clientY - event.touches[1].clientY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const scaleDelta = distance / this.startDistance;
                    
                    this.scale = Math.max(this.data.scaleMin, 
                                         Math.min(this.data.scaleMax, 
                                                 this.startScale * scaleDelta));
                    
                    this.el.object3D.scale.setScalar(this.scale);
                }
            },
            
            onTouchEnd: function() {
                this.isInteracting = false;
            }
        });

        // Custom shadow shader for better mobile performance
        AFRAME.registerShader('shadow', {
            schema: {
                opacity: {type: 'number', default: 0.3}
            },
            
            init: function(data) {
                this.material = new THREE.MeshBasicMaterial({
                    color: 0x000000,
                    transparent: true,
                    opacity: data.opacity,
                    depthWrite: false
                });
            },
            
            update: function(data) {
                this.material.opacity = data.opacity;
            }
        });

        // Error handling and fallback
        window.addEventListener('load', function() {
            const scene = document.querySelector('a-scene');
            
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                showError('Camera not supported on this device');
                return;
            }
            
            scene.addEventListener('arError', function(error) {
                console.error('AR Error:', error.detail);
                showError('AR initialization failed. Please try another device.');
            });
            
            // Check WebGL support
            if (!scene.hasWebGL) {
                showError('WebGL not supported. Please update your browser.');
            }
            
            function showError(message) {
                const errorEl = document.createElement('a-text');
                errorEl.setAttribute('value', message);
                errorEl.setAttribute('position', '0 0 -2');
                errorEl.setAttribute('align', 'center');
                errorEl.setAttribute('color', '#FF4444');
                errorEl.setAttribute('scale', '2 2 2');
                scene.appendChild(errorEl);
            }
        });
    </script>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
        }
        
        a-scene {
            width: 100vw;
            height: 100vh;
        }
        
        #scanning-text {
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        /* Prevent text selection on mobile */
        * {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
    </style>
</body>
</html>
